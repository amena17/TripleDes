/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.mycompany.tripledes.encryption;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Mints Belete
 */
public class encrypt extends javax.swing.JFrame {
    
    
    /**
     * Creates new form encryption
     */
    public encrypt() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        msg_area = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        key1 = new javax.swing.JTextField();
        key2 = new javax.swing.JTextField();
        key3 = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        encrypt = new javax.swing.JButton();
        msg_send = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        final_cipher = new javax.swing.JTextArea();
        gen_key = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        hash_area = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        clear = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        msg_area.setColumns(20);
        msg_area.setRows(5);
        jScrollPane1.setViewportView(msg_area);

        jLabel1.setText("Message");

        key2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                key2ActionPerformed(evt);
            }
        });

        key3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                key3ActionPerformed(evt);
            }
        });

        jLabel2.setText("Key 1");

        jLabel3.setText("Key 2");

        jLabel4.setText("Key 3");

        encrypt.setText("Encrypt");
        encrypt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                encryptActionPerformed(evt);
            }
        });

        msg_send.setText("Send");
        msg_send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                msg_sendActionPerformed(evt);
            }
        });

        final_cipher.setColumns(20);
        final_cipher.setRows(5);
        jScrollPane2.setViewportView(final_cipher);

        gen_key.setText("Generate Key");
        gen_key.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gen_keyActionPerformed(evt);
            }
        });

        jLabel5.setText("Final Cipher");

        jLabel7.setText("Hashed");

        clear.setForeground(java.awt.Color.red);
        clear.setText("CLEAR");
        clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearActionPerformed(evt);
            }
        });

        jPanel1.setBackground(new java.awt.Color(200, 200, 200));

        jLabel6.setFont(new java.awt.Font("Segoe UI Black", 0, 18)); // NOI18N
        jLabel6.setText("              Encryption");
        jLabel6.setIconTextGap(10);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(235, 235, 235)
                .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 173, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(24, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 62, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(17, 17, 17)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(98, 98, 98)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(key1, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(key2, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(key3, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(254, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 461, Short.MAX_VALUE)
                            .addComponent(hash_area))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(clear)
                        .addGap(30, 30, 30))))
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(260, 260, 260)
                        .addComponent(gen_key, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(263, 263, 263)
                        .addComponent(encrypt, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(251, 251, 251)
                        .addComponent(msg_send, javax.swing.GroupLayout.PREFERRED_SIZE, 163, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(gen_key, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(key1, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(key2, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(key3, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addGap(18, 18, 18)
                        .addComponent(encrypt, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(msg_send, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(hash_area, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap(12, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(clear)
                        .addGap(14, 14, 14))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    String cipherenc;
    String  finalcipher;
    String   hashedmessage;
    public class roundkeygeneration
        {
            String permutedkey[]=new String[16];
           void keys(int mode)
                {
                    
                   String  key;
                   if(mode==1)  
                       
                       { 
                           key=key1.getText();
                       }
                    else if(mode==2)
                       {
                           key=key2.getText();
                       }
                    else if(mode==3)
                       {
                           key=key3.getText();
                       }
                    else 
                       {
                           key=key3.getText();
                       }
     
                    converttobinary tobin=new converttobinary();
      
                    String convertedkey=tobin.tobinary(key);
                    
                    String keyafterpc1="";
       
                    keypermutedchoiceone  permutone=new keypermutedchoiceone();
                    keyafterpc1+=permutone.permutedchoiceone(convertedkey);
              
                    key28division  divide=new key28division();
                    String [][]dividedkey=new String[2][1];
                    dividedkey=divide.keydvistion(keyafterpc1);

            
                    //left shift by 1 
                    keyleftshift   shift=new keyleftshift();
                

              //STRING TO SAVE THE SHIFTED 56 BIT KEY
                    String  []shiftedkey=new String [16];
           
                    for(int round=1;round<=16;round++)
                        
                        {
                            
                            dividedkey[0][0]=shift.keyleftshift(dividedkey[0][0],round);
                            dividedkey[1][0]=shift.keyleftshift(dividedkey[1][0],round);

                            //CONCATNATE THE ROUND KEYS
                            shiftedkey[round-1]=dividedkey[0][0]+dividedkey[1][0];
                        }
           
            
                   //SEND THE ROUND KEY TO PERMUTATION CHOICE TWO
                    keypermutatedchoicetwo  pc2=new keypermutatedchoicetwo();
                //SAVE THE PERMUTEDTWO IN NEW STRING

                  
                    for(int l=0;l<16;l++)
                       {
                  //SEND THE SHIFTED KEY'S TO GENERATE THE ROUND KEY
                            permutedkey[l]=pc2.permutedchoicetwo(shiftedkey[l]);
                  
                  
                        }
                }
        }
    
    
    
    
    
    public class decrypt {

        decrypt(String cipherenc3)
        {
            String  message;
            message=cipherenc3;
            // converttobinary tobin=new converttobinary();
            String convertedmessage=message;
            // CALLING THE BLOCK CREATER CLASS
             no_of_blockcalculator  noblock=new no_of_blockcalculator();

            String [][]allblock=noblock.no_ofblockcalculator(convertedmessage);
            int blocklength=noblock.blockedmessage;
            int indexx=0;//block accessing variable:
            String ciphertext="";//holde only one cipher block
            String cipherblock[][]=new String[blocklength][1];
              //INTIALIZE CIPHER TO NULL
            for(int h=0;h<blocklength;h++)
            {
                cipherblock[h][0]="";
            }
                //KEY GENERATION
            roundkeygeneration keygen=new roundkeygeneration();
            int mode=2;
            keygen.keys(mode);
                  
            for(int blk=0;blk<blocklength;blk++)
            {
                int reverse=15;
                ciphertext="";
                plaintxtintialpermutation  inperm=new plaintxtintialpermutation();
                plaintxt32division  divide=new plaintxt32division();
                String beforepermutation[][]=new String[2][1];
                beforepermutation=divide.plain32divistion(allblock[blk][0]);
                String afterintial=inperm.intialpermutation(allblock[blk][0]);

                //PROCESSING PLAIN TEXT:
                String [][]dividedplain=new String[2][1];
                dividedplain=divide.plain32divistion(afterintial);
                for(int enc=0;enc<16;enc++)
                {
                    //SEND  RIGHT R TO PERMUTATION EXPANISTION
                    String []tempright=new String[1];
                    tempright[0]=dividedplain[1][0];
                    String []templeft=new String[1];
                    templeft[0]=dividedplain[0][0];
                    plaintxtRight48expanistion expand=new plaintxtRight48expanistion();
                    String []expandedRight=new  String[1];
                    expandedRight[0]=expand.expanistionpermutation(dividedplain[1][0]);
                  
                    xorplaintxtkey  xor=new xorplaintxtkey();
                       //keypermutatedchoicetwo
                    String  xoredplainn[]=new String[1];
                    xoredplainn[0]=xor.xorplainkey(expandedRight[0],keygen.permutedkey[reverse]);
                   //SENDING TO 8 SBOXES:
                    sboxs8 sboxs=new sboxs8();
                          
                    String []sboxresult=new String[1];
                    sboxresult[0]=sboxs.sboxs(xoredplainn[0]);
                     //SEND TO  PERMUTATION 32
                    r32permitation permutationP=new  r32permitation();
                           
                    String  []permutation32=new String[1];
                    permutation32[0]="";
                    permutation32[0]+=permutationP.permutation32(sboxresult[0]);
                    //XOR LEFT AND PASSED RIGHT THROUGH FUNCTION:
                    xorleftright  xorr=new xorleftright();

                    String tempFunction[]=new String[1];
                    tempFunction[0]=xorr.xorleftrigh(dividedplain[0][0],permutation32[0]);
                  
                    dividedplain[0][0]=tempright[0];
                    dividedplain[1][0]=tempFunction[0];
                  
                        ///THIS IS THE ERROR IF ANY IS THERE
                    if(reverse==0)
                    {
                        String  []lastroundoutput=new String[1];
                        lastroundoutput[0]="";
                        lastroundoutput[0]+=dividedplain[1][0]+dividedplain[0][0];

                        plaintxtintialpermutation  finalpermut= new plaintxtintialpermutation();
                        ciphertext+=finalpermut.finalpermutation(lastroundoutput[0]);
                        
                        break;    
                    }
                    reverse=reverse-1;
            }//for loop end
            cipherblock[indexx][0]+=ciphertext;
            indexx++;//the indexx that counts the block:
        }

        String finalcipher1=""; 
        for(int yy=0;yy<blocklength;yy++)
        {
            binarytostring xx=new binarytostring();
            finalcipher1+=cipherblock[yy][0];//xx.binarytostr(cipherblock[yy][0]);
        }
        //send the final cipher to the send class
        encryptt  encr=new encryptt(finalcipher1);
        
                          
                          
                          }

    }
    
    
    
    
    public class  encryptt
    {

        encryptt(String  decrypted2)
        {
            
            String  message;
     
            message=decrypted2;
      
            // converttobinary tobin=new converttobinary();
            String convertedmessage=message;//tobin.tobinary(message);
       
            // CALLING THE BLOCK CREATER CLASS
            no_of_blockcalculator  noblock=new no_of_blockcalculator();
           
            String [][]allblock=noblock.no_ofblockcalculator(convertedmessage);
            
            int blocklength=noblock.blockedmessage;
            int indexx=0;//block accessing variable:
            String ciphertext="";//holde only one cipher block
            String cipherblock[][]=new String[blocklength][1];
              //INTIALIZE CIPHER TO NULL
            for(int h=0;h<blocklength;h++)
            {
                cipherblock[h][0]="";
            }
                       
               //KEY GENERATION     
            roundkeygeneration keygen=new roundkeygeneration();
            int mode=3;
            keygen.keys(mode);
            for(int blk=0;blk<blocklength;blk++)
            {
                ciphertext="";  
                plaintxtintialpermutation  inperm=new plaintxtintialpermutation();
                plaintxt32division  divide=new plaintxt32division();
                String beforepermutation[][]=new String[2][1];
                beforepermutation=divide.plain32divistion(allblock[blk][0]);
                String afterintial=inperm.intialpermutation(allblock[blk][0]);

                //PROCESSING PLAIN TEXT:
                String [][]dividedplain=new String[2][1];
                dividedplain=divide.plain32divistion(afterintial);
                for(int enc=0;enc<16;enc++)
                {
                //SEND  RIGHT R TO PERMUTATION EXPANISTION
                    String []tempright=new String[1];
                    tempright[0]=dividedplain[1][0];
                    String []templeft=new String[1];
                    templeft[0]=dividedplain[0][0];
                    plaintxtRight48expanistion expand=new plaintxtRight48expanistion();
                    String []expandedRight=new  String[1];
                    expandedRight[0]=expand.expanistionpermutation(dividedplain[1][0]);
                  
                    xorplaintxtkey  xor=new xorplaintxtkey();
                    String  xoredplainn[]=new String[1];
                    xoredplainn[0]=xor.xorplainkey(expandedRight[0],keygen.permutedkey[enc]);
                    //SENDING TO 8 SBOXES:
                    sboxs8 sboxs=new sboxs8();
                         
                    String []sboxresult=new String[1];
                    sboxresult[0]=sboxs.sboxs(xoredplainn[0]);
                        //SEND TO  PERMUTATION 32         
                    r32permitation permutationP=new  r32permitation();
                           
                    String  []permutation32=new String[1];
                    permutation32[0]="";
                    permutation32[0]+=permutationP.permutation32(sboxresult[0]);
                   
                    //XOR LEFT AND PASSED RIGHT THROUGH FUNCTION:
                    xorleftright  xorr=new xorleftright();
                       
                    String tempFunction[]=new String[1];
                    tempFunction[0]=xorr.xorleftrigh(dividedplain[0][0],permutation32[0]);
                  
                    dividedplain[0][0]=tempright[0];
                    dividedplain[1][0]=tempFunction[0];
                  
                    ///THIS IS THE ERROR IF ANY IS THERE
                    if(enc==15)
                    {
                        String  []lastroundoutput=new String[1];
                        lastroundoutput[0]="";
                        lastroundoutput[0]+=dividedplain[1][0]+dividedplain[0][0];
                            
                        plaintxtintialpermutation  finalpermut= new plaintxtintialpermutation();
                        ciphertext+=finalpermut.finalpermutation(lastroundoutput[0]);
                    }
                }//for loop end
                cipherblock[indexx][0]+=ciphertext;
                indexx++;//the indexx that counts the block:
            }
            finalcipher="";  
            for(int yy=0;yy<blocklength;yy++)
            {
                finalcipher+=cipherblock[yy][0];
                                               

            }
           
            final_cipher.append(finalcipher);

     
                                            
        }
     
    }
    
    
    
    
    
    
    
    private void encryptActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_encryptActionPerformed
        // TODO add your handling code here:
        
        String  message;
        message=msg_area.getText();
        message=message.replaceAll(" ","_");
        message=message.replaceAll("\\.","\\^");
        converttobinary tobin=new converttobinary();
        String convertedmessage=tobin.tobinary(message);
        no_of_blockcalculator  noblock=new no_of_blockcalculator();
        String [][]allblock=noblock.no_ofblockcalculator(convertedmessage);
        int blocklength=noblock.blockedmessage;
        int indexx=0;//block accessing variable:
        String ciphertext="";//holde only one cipher block
        String cipherblock[][]=new String[blocklength][1];
        for(int h=0;h<blocklength;h++) 
            {
                cipherblock[h][0]="";
            }
        //KEY GENERATION
        roundkeygeneration keygen=new roundkeygeneration();
        int mode=1;
        keygen.keys(mode);
        
        for(int blk=0;blk<blocklength;blk++)
        {
            ciphertext="";  
            plaintxtintialpermutation  inperm=new plaintxtintialpermutation();
            plaintxt32division  divide=new plaintxt32division();
            
            String beforepermutation[][]=new String[2][1];
                   beforepermutation=divide.plain32divistion(allblock[blk][0]);
            String afterintial=inperm.intialpermutation(allblock[blk][0]);
            
                   //PROCESSING PLAIN TEXT:
            
            String [][]dividedplain=new String[2][1];
            dividedplain=divide.plain32divistion(afterintial);
            for(int enc=0;enc<16;enc++)
            {
                
                //SEND  RIGHT R TO PERMUTATION EXPANISTION
                String []tempright=new String[1];
                tempright[0]=dividedplain[1][0];
                String []templeft=new String[1];
                templeft[0]=dividedplain[0][0];
                
                plaintxtRight48expanistion expand=new plaintxtRight48expanistion();
                String []expandedRight=new  String[1];
                expandedRight[0]=expand.expanistionpermutation(dividedplain[1][0]);
                
                //xor
                xorplaintxtkey  xor=new xorplaintxtkey();
                String  xoredplainn[]=new String[1];
                xoredplainn[0]=xor.xorplainkey(expandedRight[0],keygen.permutedkey[enc]);
                
                //SENDING TO 8 SBOXES:
                sboxs8 sboxs=new sboxs8();
                String []sboxresult=new String[1];
                sboxresult[0]=sboxs.sboxs(xoredplainn[0]);
                
                //SEND TO  PERMUTATION 32
                r32permitation permutationP=new  r32permitation();
                String  []permutation32=new String[1];
                permutation32[0]="";
                permutation32[0]+=permutationP.permutation32(sboxresult[0]);
                
                //XOR LEFT AND PASSED RIGHT THROUGH FUNCTION:
                xorleftright  xorr=new xorleftright();
                String tempFunction[]=new String[1];
                tempFunction[0]=xorr.xorleftrigh(dividedplain[0][0],permutation32[0]);
                dividedplain[0][0]=tempright[0];
                dividedplain[1][0]=tempFunction[0];
                
                if(enc==15)
                {
                    String  []lastroundoutput=new String[1];
                    lastroundoutput[0]="";
                    lastroundoutput[0]+=dividedplain[1][0]+dividedplain[0][0];   
                    plaintxtintialpermutation  finalpermut= new plaintxtintialpermutation();
                    ciphertext+=finalpermut.finalpermutation(lastroundoutput[0]);
                }
            }
            cipherblock[indexx][0]+=ciphertext;
            indexx++;//the indexx that counts the block:
        }
        
        String  cipherenc1="";  
        for(int yy=0;yy<blocklength;yy++)
        {

            binarytostring xx=new binarytostring();
            cipherenc1+=cipherblock[yy][0];
        }
                                //CALLING THE DECRYPTION CLASS
        decrypt     decr=new decrypt(cipherenc1);
        cipherprinter  ciprinter=new cipherprinter(cipherblock,blocklength);
        
    }//GEN-LAST:event_encryptActionPerformed

    
    class  hash
             {
      hash(String  cipher) throws NoSuchAlgorithmException
             {
                String password = finalcipher;

        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(password.getBytes());

        byte byteData[] = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < byteData.length; i++) {
         sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
        }

        
        
        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();
    	for (int i=0;i<byteData.length;i++) {
    		String hex=Integer.toHexString(0xff & byteData[i]);
   	     	if(hex.length()==1) hexString.append('0');
   	     	hexString.append(hex);
    	}
    	
             
             hashedmessage=hexString.toString();
             finalcipher+='*'+hashedmessage;
              
              }
    
    
              }
    
    
    
    
    
    private void msg_sendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_msg_sendActionPerformed
        // TODO add your handling code here:
        try {
            //call the send class to get the cipher
            //send  rrr=new send();
            // String cipher=finalcipher;//rrr.sendciph;
            hash  nn=new hash(finalcipher);
            } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(encrypt.class.getName()).log(Level.SEVERE, null, ex);
              }
                    String cipher=finalcipher;
                    
                    hash_area.setText(hashedmessage);
                       
                            String ip="127.0.0.1";
                            String port="1234";
                            int  portint=Integer.parseInt(port);
                             try{
              Socket soc=new Socket(ip,portint);//or ipv4 address for different computers
                BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                PrintStream pr=new PrintStream(soc.getOutputStream());
                         //DataInputStream  din=new DataInputStream(soc.getInputStream());
                          //DataOutputStream  dout=new DataOutputStream(soc.getOutputStream());
                
                String msg =cipher;
                
                pr.println(msg);
               // dout.writeUTF(msg);
                
                soc.close();
                             }
            catch(IOException e){
                System.out.println(e);
                         }
    }//GEN-LAST:event_msg_sendActionPerformed

    private void key2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_key2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_key2ActionPerformed

    private void key3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_key3ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_key3ActionPerformed

    private void gen_keyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gen_keyActionPerformed
        // TODO add your handling code here:
        int k1=1,k3=15,t,t1,t2;
        Random rx=new Random();
        t=k1+rx.nextInt(k3);
        t1=k1+rx.nextInt(k3);
        t2=k1+rx.nextInt(k3);
        keyLookupTable h= new keyLookupTable();
                    String k2=h.keylookupTable1(t);
                    String k4=h.keylookupTable1(t1);
                    String k5=h.keylookupTable1(t2);
                   key1.setText(k2);
                   key2.setText(k4);
                   key3.setText(k5);
    }//GEN-LAST:event_gen_keyActionPerformed

    private void clearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearActionPerformed
        // TODO add your handling code here:
        msg_area.setText(null);
        key1.setText(null);
        key2.setText(null);
        key3.setText(null);
        final_cipher.setText(null);
        hash_area.setText(null);
        
    }//GEN-LAST:event_clearActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(encrypt.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(encrypt.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(encrypt.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(encrypt.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new encrypt().setVisible(true);
            }
        });
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clear;
    private javax.swing.JButton encrypt;
    private javax.swing.JTextArea final_cipher;
    private javax.swing.JButton gen_key;
    private javax.swing.JTextField hash_area;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField key1;
    private javax.swing.JTextField key2;
    private javax.swing.JTextField key3;
    private javax.swing.JTextArea msg_area;
    private javax.swing.JButton msg_send;
    // End of variables declaration//GEN-END:variables
}
